---
title: WebView·开车指南
date: 2016-08-18
tags: Android·Bug
author: BugDev
summary: 北京市东城区首席Bug布道师开山之作，一整月交通事故血泪经验，教你如何快速成为‘伪’老司机，开启WebView飙车之旅。
---
<br><br><br>
#WebView·开车指南
**Tips**:由于WebView的用法实在太多，如果您只是想查询某个功能的使用——建议Ctrl+F（Commad+F）在本页面搜索关键字查找。Thanks for reading~！٩(♡ε♡ )۶
<br>
  
## 前言

  喝酒不开车，开车不喝酒。

<br>
## 目录

  1. WebView简介
  2. WebView基本使用
  3. WebSettings
  4. WebViewClient
  5. WebChromeClient
  6. WebView加载优化
  7. 上路

<br>  
## WebView简介
  
  为了方便开发者实现在app内展示网页并与网页交互的需求，Android SDK提供了WebView组件。<br>它继承自AbsoluteLayout，展示网页的同时，也可以在其中放入其他的子View。<br>
  现如今，Hybrid应用似乎占据的APP的主流类型，那么关于WebView的使用就变得越发的重要。<br>从Android 4.4（KitKat）开始，原本基于WebKit的WebView开始基于Chromium内核，这一改动大大提升了WebView组件的性能以及对HTML5,CSS3,JavaScript的支持。不过它的API却没有很大的改动，在兼容低版本的同时只引进了少部分新的API，并不需要你做很大的改动。<br>
  不过有几点改变需要注意，但我尝试着翻译了下，发现还是英文原文说得好，所以我贴链接吧~~~<br>
  [Migrating to WebView in Android 4.4](https://developer.android.com/guide/webapps/migrating.html)<br><br>
  在WebView中，有几个地方是我们可以使用来定制我们的WebView各种行为的，分别是：**WebSettings**、**JavaScriptInterface**、**WebViewClient**以及**WebChromeClient**。这些我都会在接下来的文章中一一介绍。
<br><br>
##WebView基本使用
  
  下面简单介绍下WebView的基本使用：
  首先新建一个工程，在layout文件里放入一个WebView控件（当然也可以通过Java代码动态放入，这里不演示了）
  
  ```XML
  <?xml version="1.0" encoding="utf-8"?>
  <LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
      android:layout_width="match_parent"
      android:layout_height="match_parent">
  
      <WebView
          android:id="@+id/web_view"
          android:layout_width="match_parent"
          android:layout_height="match_parent"/>
  </LinearLayout>
  ```
  
  然后在Activity的onCreate方法里写入如下代码：
  ```Java
    String url = "https://www.google.com";
    WebView webView = (WebView) findViewById(R.id.web_view);
    webView.loadUrl(url);
  ```
  接着在AndroidManifest声明访问网络的权限：
  ```XML
  <uses-permission android:name="android.permission.INTERNET"/>
  ```
  就，完事了~
  这时运行app，它已经可以访问指定地址的网页了。
  <br>
  ---
  <br>
  上面提到了WebView继承自AbsoluteLayout，可以在其中放入一些子View，那也顺手来一下。
  Layout文件改为：
  ```XML
  <?xml version="1.0" encoding="utf-8"?>
  <LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <WebView
        android:id="@+id/web_view"
        android:layout_width="match_parent"
        android:layout_height="match_parent">

        <Button
            android:id="@+id/button"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_x="170dp"
            android:layout_y="400dp"
            android:background="@color/colorAccent"
            android:text="@string/app_name" />
    </WebView>
  </LinearLayout>
  ```
  
  Activity的onCreate里加上：
  ```Java
    Button button = (Button) findViewById(R.id.button);
    button.setOnClickListener(new View.OnClickListener() {
        @Override
        public void onClick(View view) {
            Toast.makeText(getApplicationContext(), "系好安全带!", Toast.LENGTH_SHORT).show();
        }
    });
  ```
  这时，运行app，里面就会多出一个Button~ 但如果你真的运行的话，你就会发现，app会自动跳到浏览器并打开指定的网页，而并非在app内展示网页，那这就与我们的初衷背道而驰了，那么要如何实现网页在App内打开呢?这就引出了下面的章节会提到的东西：WebViewClient。我先将代码贴出，具体实现原理留到下节说明。
  
  最终XML布局就如上面那样，Java代码（最终）如下：
  ```Java
public class MainActivity extends AppCompatActivity {

        @Override
        protected void onCreate(Bundle savedInstanceState) {
            super.onCreate(savedInstanceState);
            setContentView(R.layout.activity_main);

            String url = "https://www.google.com";
            WebView webView = (WebView) findViewById(R.id.web_view);
            webView.loadUrl(url);

            webView.setWebViewClient(new WebViewClient() {
                @Override
                public boolean shouldOverrideUrlLoading(WebView view, WebResourceRequest request) {
                    view.loadUrl(request.toString());
                    return true;
                }
            });

            Button button = (Button) findViewById(R.id.button);
            button.setOnClickListener(new View.OnClickListener() {
                @Override
                public void onClick(View view) {
                    Toast.makeText(getApplicationContext(), "系好安全带!", Toast.LENGTH_SHORT).show();
                }
            });
        }
}
  ```
  
  效果图：
  <br>
  <img src="https://cloud.githubusercontent.com/assets/12692071/17649176/5ffb5b44-6260-11e6-84dc-2ac41be1b858.gif" width="300" height="550" />
  <br>
  <br>
  
  <br>
##WebSettings

  WebSettings是用来管理WebView配置的类。当WebView第一次创建时，内部会包含一个默认配置的集合。若我们想更改这些配置，便可以通过WebSettings里的方法来进行设置。<br>
  WebSettings对象可以通过***WebView.getSettings()***获得，它的生命周期是与它的WebView本身息息相关的，如果WebView被销毁了，那么任何由WebSettings调用的方法也同样不能使用。<br>
  <br>
###获取WebSettings对象
  
  ```Java
  WebSettings webSettings = webView.getSettings();
  ```
  <br>
###WebSettings常用方法
（几乎所有的set方法都有相应的get方法，这里就只介绍set了。**另，所有未写方法返回值类型的皆为空类型**）

  - **setJavaScriptEnabled**(boolean flag)：设置WebView是否可以运行JavaScript。
  <br>
  <br>
  - **setJavaScriptCanOpenWindowsAutomatically**(boolean flag)：设置WebView是否可以由JavaScript自动打开窗口，默认为false，通常与JavaScript的***window.open()***配合使用。
  <br>
  <br>
  <br>
  <br>
  - **setAllowFileAccess**(boolean allow)：启用或禁用WebView访问文件数据。
  <br>
  <br>
  - **setBlockNetworkImage**(boolean flag)：禁止或允许WebView从网络上加载图片。需要注意的是，如果设置是从禁止到允许的转变的话，图片数据并不会在设置改变后立刻去获取，而是在WebView调用reload()的时候才会生效。<br>这个时候，需要确保这个app拥有访问Internet的权限，否则会抛出安全异常。<br>通常没有禁止图片加载的需求的时候，完全不用管这个方法，因为当我们的app拥有访问Internet的权限时，这个flag的默认值就是false。
  <br>
  <br>
  - **setSupportZoom**(boolean support)：设置是否支持缩放。
  <br>
  <br>
  - **setBuiltInZoomControls**(boolean enabled)：显示或不显示缩放按钮（wap网页不支持）。
  <br>
  <br>
  - **setSupportMultipleWindows**(boolean support)：设置WebView是否支持多窗口。
  <br>
  <br>
  - **setLayoutAlgorithm**(WebSettings.LayoutAlgorithm l)：指定WebView的页面布局显示形式，调用该方法会引起页面重绘。默认值为LayoutAlgorithm#NARROW_COLUMNS。
  <br>
  <br>
  - **setNeedInitialFocus(boolean flag)**：通知WebView是否需要设置一个节点获取焦点当WebView#requestFocus(int,android.graphics.Rect)被调用时，默认为true。
  <br>
  <br>
  <br>
  <br>
  - **setAppCacheEnabled(boolean flag)**：启用或禁用应用缓存。
  <br>
  <br>
  - **setAppCachePath(String appCachePath)**：设置应用缓存路径，这个路径必须是可以让app写入文件的。该方法应该只被调用一次，重复调用会被无视~
  <br>
  <br>
  - **setCacheMode(int mode)**：**用来设置WebView的缓存模式。**当我们加载页面或从上一个页面返回的时候，会按照设置的缓存模式去检查并使用（或不使用）缓存。
  <br>
    缓存模式有四种：
      <br>
      1. **LOAD_DEFAULT**：默认的缓存使用模式。在进行页面前进或后退的操作时，如果缓存可用并未过期就优先加载缓存，否则从网络上加载数据。这样可以减少页面的网络请求次数。
      <br>
      2. **LOAD_CACHE_ELSE_NETWORK**：只要缓存可用就加载缓存，哪怕它们已经过期失效。如果缓存不可用就从网络上加载数据。
      <br>
      3. **LOAD_NO_CACHE**：不加载缓存，只从网络加载数据。
      <br>
      4. **LOAD_CACHE_ONLY**：不从网络加载数据，只从缓存加载数据。
  <br>
  通常我们可以根据网络情况将这几种模式结合使用，比如有网的时候使用LOAD_DEFAULT，离线时使用LOAD_CACHE_ONLY、LOAD_CACHE_ELSE_NETWORK，让用户不至于在离线时啥都看不到。
  <br>
  - **setDatabaseEnabled(boolean flag)**：启用或禁用数据库缓存。
  <br>
  <br>
  - **setDomStorageEnabled(boolean flag)**：启用或禁用DOM缓存。
  <br>
  <br>
  <br>
  <br>
  - **setUserAgentString(String ua)**：设置WebView的UserAgent值。
  <br>
  <br>
  - **setDefaultEncodingName(String encoding)**：设置编码格式，通常都设为“UTF-8”。
  <br>
  <br>
  <br>
  <br>
  - **setStandardFontFamily(String font)**：设置标准的字体族，默认“sans-serif”。
  <br>
  <br>
  - **setCursiveFontFamily**：设置草书字体族，默认“cursive”。
  <br>
  <br>
  - **setFantasyFontFamily**：设置CursiveFont字体族，默认“cursive”。
  <br>
  <br>
  - **setFixedFontFamily**：设置混合字体族，默认“monospace”。
  <br>
  <br>
  - **setSansSerifFontFamily**：设置梵文字体族，默认“sans-serif”。
  <br>
  <br>
  - **setSerifFontFamily**：设置衬线字体族，默认“sans-serif” 
  <br>
  <br>
  - **setDefaultFixedFontSize(int size)**：设置默认填充字体大小，默认16，取值区间为[1-72]，超过范围，使用其上限值。
  <br>
  <br>
  - **setDefaultFontSize(int size)**：设置默认字体大小，默认16，取值区间[1-72]，超过范围，使用其上限值。
  <br>
  <br>
  - **setMinimumFontSize**：设置最小字体，默认8. 取值区间[1-72]，超过范围，使用其上限值。 
  <br>
  <br>
  - **setMinimumLogicalFontSize**：设置最小逻辑字体，默认8. 取值区间[1-72]，超过范围，使用其上限值。 
  <br>
  <br>
  <br>
  <br>
以上就是一些WebSettings的常用方法，具体的使用以及一些缓存的问题会在接下来的代码以及文章中有更加直观的说明。

<br>
<br>
<br>
<br>
##WebViewClient
  
  从名字上不难理解，这个类就像WebView的委托人一样，是帮助WebView处理各种通知和请求事件的。


  - **onLoadResource(WebView view, String url)**：该方法在加载页面资源时会回调，每一个资源（比如图片）的加载都会调用一次。
  <br>
  <br>
  - **onPageStarted(WebView view, String url, Bitmap favicon)**：该方法在WebView开始加载页面且仅在***Main frame loading***（即***整页加载***）时回调，一个页面只调用一次。我们可以在这个方法里设定开启一个加载的动画，告诉用户程序在等待网络的响应。
  <br>
  <br>
  - **onPageFinished(WebView view, String url)**：该方法在WebView加载一个页面结束时调用（同样也只在***main frame loading***时调用），**理论上**可以在此时关闭加载动画，进行其他操作。___（这里有一坑，后面会进一步介绍）___
  <br>
  <br>
  - **onReceivedError(WebView view, WebResourceRequest request, WebResourceError error)**：该方法在web页面加载错误时回调，这些错误通常都是由无法与服务器正常连接引起的，最常见的就是网络问题。
  <br>这个方法有两个地方需要注意：
  <br>1. 这个方法只在与服务器无法正常连接时调用，类似于服务器返回错误码的那种错误，该方法是不会回调的，因为你已经和服务器正常连接上了（全怪官方文档(︶^︶)）；
  <br>2. 这个方法是新版本的onReceivedError()方法，从API23开始引进，与旧方法onReceivedError(WebView view,int errorCode,String description,String failingUrl)不同的是，新方法在页面局部加载发生错误时也会被调用（比如页面里两个子Tab或者一张图片）。这就意味着该方法的调用频率可能会更加频繁，所以我们应该在该方法里执行尽量少的操作。
  <br>
  <br>
  - **onReceivedHttpError(WebView view, WebResourceRequest request, WebResourceResponse errorResponse)**：
  <br>
  <br>
  - **onReceivedSslError(WebView view, SslErrorHandler handler, SslError error)**：
  <br>
  <br>
  - **WebResourceResponse	shouldInterceptRequest(WebView view, WebResourceRequest request)**：
  <br>
  - **boolean	shouldOverrideUrlLoading(WebView view, WebResourceRequest request)**：
  <br>
  <br>
  - **onPageCommitVisible(WebView view, String url)**：
  <br>
  <br>
  - **onReceivedHttpAuthRequest(WebView view, HttpAuthHandler handler, String host, String realm)**：
  <br>
  <br>
  - **onReceivedLoginRequest(WebView view, String realm, String account, String args)**：
  <br>
  <br>
  - **onScaleChanged(WebView view, float oldScale, float newScale)**：
  <br>
  <br>
  - **boolean	shouldOverrideKeyEvent(WebView view, KeyEvent event)**：
  <br>
  <br>


