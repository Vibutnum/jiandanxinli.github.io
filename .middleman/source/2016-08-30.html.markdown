---
title: WebView·开车指南
date: 2016-08-18
tags: Android·Bug
author: BugDev
summary: 北京市东城区首席Bug布道师开山之作，一整月交通事故血泪经验，教你如何快速成为‘伪’老司机，开启WebView飙车之旅。
---
<br><br><br>
#WebView·开车指南
**Tips**
  1. 由于WebView的用法实在太多，如果您只是想查询某个功能的使用——建议Ctrl+F（Commad+F）在本页面搜索关键字查找。<br>
  2. 文章给前半部分大多是方法的介绍，若嫌琐碎可直接拖到最后看代码演示。
<br>
<br>
<br>
**Thanks for reading~！**٩(♡ε♡ )۶
<br>
<br>
<br>
<br>
  
## 前言

  喝酒不开车，开车不喝酒。

<br>
## 目录

  1. WebView简介
  2. WebView基本使用
  3. WebView常用方法
  4. WebSettings
  5. WebViewClient
  6. WebChromeClient
  7. JavaScript与WebView交互
  8. WebView加载优化
  9. 驾照考试
  10. 上路
  

## WebView简介
  
  为了方便开发者实现在app内展示网页并与网页交互的需求，Android SDK提供了WebView组件。<br>它继承自AbsoluteLayout，展示网页的同时，也可以在其中放入其他的子View。<br>
  现如今，Hybrid应用似乎占据的APP的主流类型，那么关于WebView的使用就变得越发的重要。<br>从Android 4.4（KitKat）开始，原本基于WebKit的WebView开始基于Chromium内核，这一改动大大提升了WebView组件的性能以及对HTML5,CSS3,JavaScript的支持。不过它的API却没有很大的改动，在兼容低版本的同时只引进了少部分新的API，并不需要你做很大的改动。<br>
  不过有几点改变需要注意，但我尝试着翻译了下，发现还是英文原文说得好，所以我贴链接吧~~~<br>
  [Migrating to WebView in Android 4.4](https://developer.android.com/guide/webapps/migrating.html)<br><br>
  在WebView中，有几个地方是我们可以使用来定制我们的WebView各种行为的，分别是：**WebSettings**、**JavaScriptInterface**、**WebViewClient**以及**WebChromeClient**。这些我都会在接下来的文章中一一介绍。
<br><br>
## WebView基本使用
  
  下面简单介绍下WebView的基本使用：
  首先新建一个工程，在layout文件里放入一个WebView控件（当然也可以通过Java代码动态放入，这里不演示了）
  
  ```XML
  <?xml version="1.0" encoding="utf-8"?>
  <LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
      android:layout_width="match_parent"
      android:layout_height="match_parent">
  
      <WebView
          android:id="@+id/web_view"
          android:layout_width="match_parent"
          android:layout_height="match_parent"/>
  </LinearLayout>
  ```
  
  然后在Activity的onCreate方法里写入如下代码：
  ```Java
    String url = "https://www.google.com";
    WebView webView = (WebView) findViewById(R.id.web_view);
    webView.loadUrl(url);
  ```
  接着在AndroidManifest声明访问网络的权限：
  ```XML
  <uses-permission android:name="android.permission.INTERNET"/>
  ```
  就，完事了~
  这时运行app，它已经可以访问指定地址的网页了。
  <br>
  ---
  <br>
  上面提到了WebView继承自AbsoluteLayout，可以在其中放入一些子View，那也顺手来一下。
  Layout文件改为：
  ```XML
  <?xml version="1.0" encoding="utf-8"?>
  <LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <WebView
        android:id="@+id/web_view"
        android:layout_width="match_parent"
        android:layout_height="match_parent">

        <Button
            android:id="@+id/button"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_x="170dp"
            android:layout_y="400dp"
            android:background="@color/colorAccent"
            android:text="@string/app_name" />
    </WebView>
  </LinearLayout>
  ```
  
  Activity的onCreate里加上：
  ```Java
    Button button = (Button) findViewById(R.id.button);
    button.setOnClickListener(new View.OnClickListener() {
        @Override
        public void onClick(View view) {
            Toast.makeText(getApplicationContext(), "系好安全带!", Toast.LENGTH_SHORT).show();
        }
    });
  ```
  这时，运行app，里面就会多出一个Button~ 但如果你真的运行的话，你就会发现，app会自动跳到浏览器并打开指定的网页，而并非在app内展示网页，那这就与我们的初衷背道而驰了，那么要如何实现网页在App内打开呢?这就引出了下面的章节会提到的东西：WebViewClient。我先将代码贴出，具体实现原理留到下节说明。
  
  最终XML布局就如上面那样，Java代码（最终）如下：
  ```Java
public class MainActivity extends AppCompatActivity {

        @Override
        protected void onCreate(Bundle savedInstanceState) {
            super.onCreate(savedInstanceState);
            setContentView(R.layout.activity_main);

            String url = "https://www.google.com";
            WebView webView = (WebView) findViewById(R.id.web_view);
            webView.loadUrl(url);

            webView.setWebViewClient(new WebViewClient() {
                @Override
                public boolean shouldOverrideUrlLoading(WebView view, WebResourceRequest request) {
                    view.loadUrl(request.toString());
                    return true;
                }
            });

            Button button = (Button) findViewById(R.id.button);
            button.setOnClickListener(new View.OnClickListener() {
                @Override
                public void onClick(View view) {
                    Toast.makeText(getApplicationContext(), "系好安全带!", Toast.LENGTH_SHORT).show();
                }
            });
        }
}
  ```
  
  效果图：
  <br>
  <img src="https://cloud.githubusercontent.com/assets/12692071/17649176/5ffb5b44-6260-11e6-84dc-2ac41be1b858.gif" width="300" height="550" />
  <br>
  <br>
  
## WebView简介
  
  接下来再介绍一些WebView的常用方法，具体演示会在后面章节的代码里统一展示。
  
  <br>
  <br>
    - String **getUrl**()：获取当前页面的URL。
  <br>
  <br>
    - **reload**()：重新reload当前的URL，即刷新。
  <br>
  <br>  
  <br>
  <br>
    - boolean **canGoBack**()：用来确认WebView里是否还有可回退的历史记录。通常我们会在WebView里重写返回键的点击事件，通过该方法判断WebView里是否还有历史记录，若有则返回上一页。
  <br>
  <br>
    - boolean **canGoForward**()：用来确认WebView是否还有可向前的历史记录。
  <br>
  <br>
    - boolean **canGoBackOrForward**(int steps)：以当前的页面为起始点，用来确认WebView的历史记录是否足以后退或前进给定的步数，正数为前进，负数为后退。
  <br>
  <br>
    - **goBack**()：在WebView历史记录后退到上一项。
  <br>
  <br>
    - **goForward**()：在WebView历史记录里前进到下一项。
  <br>
  <br>
    - **goBackOrForward**(int steps)：以当前页面为起始点，前进或后退历史记录中指定的步数，正数为前进，负数为后退。
  <br>
  <br>
  <br>
  <br>
    - **clearCache**(boolean includeDiskFiles)：清空网页访问留下的缓存数据。需要注意的时，由于缓存是全局的，所以只要是WebView用到的缓存都会被清空，即便其他地方也会使用到。该方法接受一个参数，从命名即可看出作用。若设为false，则只清空内存里的资源缓存，而不清空磁盘里的。
  <br>
  <br>
    - **clearHistory**()：清除当前webview访问的历史记录。
  <br>
  <br>
    - **clearFormData**()：清除自动完成填充的表单数据。需要注意的是，该方法仅仅清除**当前表单域自动完成填充的表单数据**，并不会清除WebView存储到本地的数据。
  <br>
  <br>
  <br>
  <br>
    - **onPause**()：当页面被失去焦点被切换到后台不可见状态，需要执行onPause操作，该操作会通知内核安全地暂停所有动作，比如动画的执行或定位的获取等。需要注意的是该方法并不会暂停JavaScript的执行，若要暂停JavaScript的执行请使用接下来的这个方法。
  <br>
  <br>
    - **onResume**()：在先前调用***onPause()***后，我们可以调用该方法来恢复WebView的运行。
  <br>
  <br>
    - **pauseTimers**()：该方法面向全局整个应用程序的webview，它会暂停所有webview的layout，parsing，JavaScript Timer。当程序进入后台时，该方法的调用可以降低CPU功耗。
  <br>
  <br>
    - **resumeTimers**()：恢复pauseTimers时的所有操作。
  <br>
  <br>
    - **destroy**()：销毁WebView。需要注意的是：这个方法的调用应在WebView从父容器中被remove掉之后。我们可以手动地调用
  ```Java
    rootLayout.removeView(webView);
    webView.destroy();
  ```
  
  <br>
  <br>
  <br>
  <br>
    - **getScrollY**()：该方法返回的当前可见区域的顶端距整个页面顶端的距离，也就是当前内容滚动的距离。
  <br>
  <br>
    - **getHeight**()：方法都返回当前WebView这个容器的高度。其实以上两个方法都属于View。
  <br>
  <br>
    - **getContentHeight**()：该方法返回整个HTML页面的高度，但该高度值并不等同于当前整个页面的高度，因为WebView有缩放功能， 所以当前整个页面的高度实际上应该是原始HTML的高度再乘上缩放比例。因此，准确的判断方法应该是
  ```Java
    if (webView.getContentHeight() * webView.getScale() == (webView.getHeight() + webView.getScrollY())) {
        //已经处于底端
    }
    
    if(webView.getScrollY() == 0){
        //处于顶端
    }
```
  <br>
  <br>
    - **pageUp**()：待斟酌。
  <br>
  <br>
    - **pageDown**()：待斟酌。
  <br>
  <br>
  
  <br>
##WebSettings

  WebSettings是用来管理WebView配置的类。当WebView第一次创建时，内部会包含一个默认配置的集合。若我们想更改这些配置，便可以通过WebSettings里的方法来进行设置。<br>
  WebSettings对象可以通过***WebView.getSettings()***获得，它的生命周期是与它的WebView本身息息相关的，如果WebView被销毁了，那么任何由WebSettings调用的方法也同样不能使用。<br>
  <br>
###获取WebSettings对象
  
  ```Java
    WebSettings webSettings = webView.getSettings();
  ```
  <br>
###WebSettings常用方法
（几乎所有的set方法都有相应的get方法，这里就只介绍set了。**另，所有未写方法返回值类型的皆为空类型**）

  - **setJavaScriptEnabled**(boolean flag)：设置WebView是否可以运行JavaScript。
  <br>
  <br>
  - **setJavaScriptCanOpenWindowsAutomatically**(boolean flag)：设置WebView是否可以由JavaScript自动打开窗口，默认为false，通常与JavaScript的***window.open()***配合使用。
  <br>
  <br>
  <br>
  <br>
  - **setAllowFileAccess**(boolean allow)：启用或禁用WebView访问文件数据。
  <br>
  <br>
  - **setBlockNetworkImage**(boolean flag)：禁止或允许WebView从网络上加载图片。需要注意的是，如果设置是从禁止到允许的转变的话，图片数据并不会在设置改变后立刻去获取，而是在WebView调用reload()的时候才会生效。<br>这个时候，需要确保这个app拥有访问Internet的权限，否则会抛出安全异常。<br>通常没有禁止图片加载的需求的时候，完全不用管这个方法，因为当我们的app拥有访问Internet的权限时，这个flag的默认值就是false。
  <br>
  <br>
  - **setSupportZoom**(boolean support)：设置是否支持缩放。
  <br>
  <br>
  - **setBuiltInZoomControls**(boolean enabled)：显示或不显示缩放按钮（wap网页不支持）。
  <br>
  <br>
  - **setSupportMultipleWindows**(boolean support)：设置WebView是否支持多窗口。
  <br>
  <br>
  - **setLayoutAlgorithm**(WebSettings.LayoutAlgorithm l)：指定WebView的页面布局显示形式，调用该方法会引起页面重绘。默认值为LayoutAlgorithm#NARROW_COLUMNS。
  <br>
  <br>
  - **setNeedInitialFocus(boolean flag)**：通知WebView是否需要设置一个节点获取焦点当WebView#requestFocus(int,android.graphics.Rect)被调用时，默认为true。
  <br>
  <br>
  <br>
  <br>
  - **setAppCacheEnabled(boolean flag)**：启用或禁用应用缓存。
  <br>
  <br>
  - **setAppCachePath(String appCachePath)**：设置应用缓存路径，这个路径必须是可以让app写入文件的。该方法应该只被调用一次，重复调用会被无视~
  <br>
  <br>
  - **setCacheMode(int mode)**：**用来设置WebView的缓存模式。**当我们加载页面或从上一个页面返回的时候，会按照设置的缓存模式去检查并使用（或不使用）缓存。
  <br>
    缓存模式有四种：
      <br>
      1. **LOAD_DEFAULT**：默认的缓存使用模式。在进行页面前进或后退的操作时，如果缓存可用并未过期就优先加载缓存，否则从网络上加载数据。这样可以减少页面的网络请求次数。
      <br>
      2. **LOAD_CACHE_ELSE_NETWORK**：只要缓存可用就加载缓存，哪怕它们已经过期失效。如果缓存不可用就从网络上加载数据。
      <br>
      3. **LOAD_NO_CACHE**：不加载缓存，只从网络加载数据。
      <br>
      4. **LOAD_CACHE_ONLY**：不从网络加载数据，只从缓存加载数据。
  <br>
  通常我们可以根据网络情况将这几种模式结合使用，比如有网的时候使用LOAD_DEFAULT，离线时使用LOAD_CACHE_ONLY、LOAD_CACHE_ELSE_NETWORK，让用户不至于在离线时啥都看不到。
  <br>
  <br>
  <br>
  - **setDatabaseEnabled(boolean flag)**：启用或禁用数据库缓存。
  <br>
  <br>
  - **setDomStorageEnabled(boolean flag)**：启用或禁用DOM缓存。
  <br>
  <br>
  <br>
  <br>
  - **setUserAgentString(String ua)**：设置WebView的UserAgent值。
  <br>
  <br>
  - **setDefaultEncodingName(String encoding)**：设置编码格式，通常都设为“UTF-8”。
  <br>
  <br>
  <br>
  <br>
  - **setStandardFontFamily(String font)**：设置标准的字体族，默认“sans-serif”。
  <br>
  <br>
  - **setCursiveFontFamily**：设置草书字体族，默认“cursive”。
  <br>
  <br>
  - **setFantasyFontFamily**：设置CursiveFont字体族，默认“cursive”。
  <br>
  <br>
  - **setFixedFontFamily**：设置混合字体族，默认“monospace”。
  <br>
  <br>
  - **setSansSerifFontFamily**：设置梵文字体族，默认“sans-serif”。
  <br>
  <br>
  - **setSerifFontFamily**：设置衬线字体族，默认“sans-serif” 
  <br>
  <br>
  - **setDefaultFixedFontSize(int size)**：设置默认填充字体大小，默认16，取值区间为[1-72]，超过范围，使用其上限值。
  <br>
  <br>
  - **setDefaultFontSize(int size)**：设置默认字体大小，默认16，取值区间[1-72]，超过范围，使用其上限值。
  <br>
  <br>
  - **setMinimumFontSize**：设置最小字体，默认8. 取值区间[1-72]，超过范围，使用其上限值。 
  <br>
  <br>
  - **setMinimumLogicalFontSize**：设置最小逻辑字体，默认8. 取值区间[1-72]，超过范围，使用其上限值。 
  <br>
  <br>
  <br>
  <br>
以上就是一些WebSettings的常用方法，具体的使用以及一些缓存的问题会在接下来的代码以及文章中有更加直观的说明。

<br>
<br>
<br>
<br>
##WebViewClient
  
  从名字上不难理解，这个类就像WebView的委托人一样，是帮助WebView处理各种通知和请求事件的，我们可以称他为WebView的“内政大臣”。


  - **onLoadResource(WebView view, String url)**：该方法在加载页面资源时会回调，每一个资源（比如图片）的加载都会调用一次。
  <br>
  <br>
  - **onPageStarted(WebView view, String url, Bitmap favicon)**：该方法在WebView开始加载页面且仅在**Main frame loading**（即***整页加载***）时回调，一次Main frame的加载只会回调该方法一次。我们可以在这个方法里设定开启一个加载的动画，告诉用户程序在等待网络的响应。
  <br>
  <br>
  - **onPageFinished(WebView view, String url)**：该方法只在WebView完成一个页面加载时调用一次（同样也只在**Main frame loading**时调用），我们可以可以在此时关闭加载动画，进行其他操作。
  <br>
  <br>
  - **onReceivedError(WebView view, WebResourceRequest request, WebResourceError error)**：该方法在web页面加载错误时回调，这些错误通常都是由无法与服务器正常连接引起的，最常见的就是网络问题。
  <br>这个方法有两个地方需要注意：
  <br>
  1.这个方法只在与服务器无法正常连接时调用，类似于服务器返回错误码的那种错误（即**HTTP ERROR**），该方法是不会回调的，因为你已经和服务器正常连接上了（全怪官方文档(︶^︶)）；<br>
  2.这个方法是新版本的onReceivedError()方法，从API23开始引进，与旧方法onReceivedError(WebView view,int errorCode,String description,String failingUrl)不同的是，新方法在页面局部加载发生错误时也会被调用（比如页面里两个子Tab或者一张图片）。这就意味着该方法的调用频率可能会更加频繁，所以我们应该在该方法里执行尽量少的操作。
  <br>
  <br>
  - **onReceivedHttpError(WebView view, WebResourceRequest request, WebResourceResponse errorResponse)**：上一个方法提到onReceivedError并不会在服务器返回错误码时被回调，那么当我们需要捕捉HTTP ERROR并进行相应操作时应该怎么办呢？**API23**便引入了该方法。当服务器返回一个HTTP ERROR并且它的status code>=400时，该方法便会回调。这个方法的作用域并不局限于Main Frame，任何资源的加载引发HTTP ERROR都会引起该方法的回调，所以我们也应该在该方法里执行尽量少的操作，只进行非常必要的错误处理等。
  <br>
  <br>
  - **onReceivedSslError(WebView view, SslErrorHandler handler, SslError error)**：当WebView加载某个资源引发SSL错误时会回调该方法，这时WebView要么执行handler.cancel()取消加载，要么执行handler.proceed()方法继续加载（默认为cancel）。需要注意的是，这个决定可能会被保留并在将来再次遇到SSL错误时执行同样的操作。
  <br>
  <br>
  - **WebResourceResponse	shouldInterceptRequest(WebView view, WebResourceRequest request)**：当WebView需要请求某个数据时，这个方法可以拦截该请求来告知app并且允许app本身返回一个数据来替代我们原本要加载的数据。
  <br>
  比如你对web的某个js做了本地缓存，希望在加载该js时不再去请求服务器而是可以直接读取本地缓存的js，这个方法就可以帮助你完成这个需求。你可以写一些逻辑检测这个request，并返回相应的数据，你返回的数据就会被WebView使用，如果你返回null，WebView会继续向服务器请求。
  <br>
  <br>
  - **boolean	shouldOverrideUrlLoading(WebView view, WebResourceRequest request)**：哈~ 终于到了这个方法，在最开始的基础演示时我们用到了这个方法。从实践中我们知道，当我们没有给WebView提供WebViewClient时，WebView如果要加载一个url会向ActivityManager寻求一个适合的处理者来加载该url（比如系统自带的浏览器），这通常是我们不想看到的。于是我们需要给WebView提供一个WebViewClient，并重写该方法返回true来告知WebView url的加载就在app中进行。这时便可以实现在app内访问网页。
  <br>
  <br>
  <br>
  <br>
  - **onReceivedHttpAuthRequest(WebView view, HttpAuthHandler handler, String host, String realm)**：待斟酌。
  <br>
  <br>
  - **onReceivedLoginRequest(WebView view, String realm, String account, String args)**：待斟酌。
  <br>
  <br>
  - **onScaleChanged(WebView view, float oldScale, float newScale)**：当WebView得页面Scale值发生改变时回调。
  <br>
  <br>
  - **boolean	shouldOverrideKeyEvent(WebView view, KeyEvent event)**：默认值为false，重写此方法并return true可以让我们在WebView内处理按键事件。
  <br>
  <br>
  <br>
  <br>

##WebChromeClient

  如果说WebViewClient是帮助WebView处理各种通知、请求事件的“内政大臣”的话，那么WebChromeClient就是辅助WebView处理Javascript的对话框，网站图标，网站title，加载进度等偏外部事件的“外交大臣”。
  
  
  - onProgressChanged(WebView view, int newProgress)：当页面加载的进度发生改变时回调，用来告知主程序当前页面的加载进度。
  <br>
  <br>
  <br>
  <br>
  - onReceivedIcon(WebView view, Bitmap icon)：用来接收web页面的icon，我们可以在这里将该页面的icon设置到Toolbar。
  <br>
  <br>
  - onReceivedTitle(WebView view, String title)：用来接收web页面的title，我们可以在这里将页面的title设置到Toolbar。
  <br>
  <br>
  <br>
  <br>
以下两个方法是为了支持web页面进入全屏模式而存在的（比如播放视频），如果不实现这两个方法，该web上的内容便不能进入全屏模式。<br>
  - onShowCustomView(View view, WebChromeClient.CustomViewCallback callback)：该方法在当前页面进入全屏模式时回调，主程序必须提供一个包含当前web内容（视频 or Something）的自定义的View。
  <br>
  <br>
  - onHideCustomView()：该方法在当前页面退出全屏模式时回调，主程序应在这时隐藏之前show出来的View。
  <br>
  <br>
  <br>
  <br>
  - Bitmap getDefaultVideoPoster()：当我们的Web页面包含视频时，我们可以在HTML里为它设置一个预览图，WebView会在绘制页面时根据它的宽高为它布局。而当我们处于弱网状态下时，我们没有比较快的获取该图片，那WebView绘制页面时的gitWidth()方法就会报出空指针异常~ 于是app就crash了。。<br>
  这时我们就需要重写该方法，在我们尚未获取web页面上的video预览图时，给予它一个本地的图片，避免空指针的发生。
  <br>
  <br>
  - View getVideoLoadingProgressView()：重写该方法可以在视频loading时给予一个自定义的View，可以是加载圆环 or something。
  <br>
  <br>
  <br>
  <br>
  - boolean	onJsAlert(WebView view, String url, String message, JsResult result)：处理Javascript中的Alert对话框。
  <br>
  <br>
  - boolean	onJsPrompt(WebView view, String url, String message, String defaultValue, JsPromptResult result)：处理Javascript中的Prompt对话框。
  <br>
  <br>
  - boolean	onJsBeforeUnload(WebView view, String url, String message, JsResult result)：待斟酌
  <br>
  <br>
  - boolean	onJsConfirm(WebView view, String url, String message, JsResult result)：处理Javascript中的Confirm对话框
  <br>
  <br>
  <br>
  <br>
  - boolean	onShowFileChooser(WebView webView, ValueCallback<Uri[]> filePathCallback, WebChromeClient.FileChooserParams fileChooserParams)：该方法在用户进行了web上某个需要上传文件的操作时回调。我们应该在这里打开一个文件选择器，如果要取消这个请求我们可以调用***filePathCallback.onReceiveValue(null)***并返回***true***。
  <br>
  <br>
  <br>
  <br>
  - onPermissionRequest(PermissionRequest request)：该方法在web页面请求某个尚未被允许或拒绝的权限时回调，主程序在此时调用***grant(String [])***或***deny()***方法。如果该方法没有被重写，则默认拒绝web页面请求的权限。
  <br>
  <br>
  - onPermissionRequestCanceled(PermissionRequest request)：该方法在web权限申请权限被取消时回调，这时应该隐藏任何与之相关的UI界面。
  <br>
  <br>
  <br>
  <br>
  
##Js与WebVipew交互

  既然嗨鸟应用大行其道，那么毫无疑问Android与JavaScript的交互我们也必须了解清楚，下面来介绍一下JavaScript与Android是如何互相调用的。
  <br>
  <br>
  
###利用WebView调用网页上的JavaScript代码
  
  在WebView中调用Js的基本格式为**webView.loadUrl("javascript:methodName(parameterValues)");**
  <br>
  <br>
  **现有以下这段JavaScript代码**
  ```JavaScript
  <script type="text/javascript">
      function readyToGo() {
          alert("Hello")
      }
  
      function alertMessage(message) {
          alert(message)
      }
  
      function getYourCar(){
          return "Car";
      }
  </script>
  ```
  <br>
####1. WebView调用JavaScript无参无返回值函数

  ```Java
  String call = "javascript:readyToGo()";
  webView.loadUrl(call);
  ```
  <br>
####2. WebView调用JavScript有参无返回值函数

  ```Java
  String call = "javascript:alertMessage(\"" + "content" + "\")";
  webView.loadUrl(call);
  ```
  <br>
####3. WebView调用JavaScript有参数有返回值的函数
  
  ```Java
  @TargetApi(Build.VERSION_CODES.KITKAT)
  private void evaluateJavaScript(WebView webView){
      webView.evaluateJavascript("getYourCar()", new ValueCallback<String>() {
          @Override
          public void onReceiveValue(String s) {
              Log.d("findCar",s);
          }
      });
  }
  ```
  
  <br>
  <br>


###JavaScript通过WebView调用Java代码

  从API19开始，Android提供了@JavascriptInterface对象注解的方式来建立起Javascript对象和Android原生对象的绑定，提供给JavScript调用的函数必须带有@JavascriptInterface。

  **演示一 JavaScript调用Android Toast方法**
  
  **1. 编写Java原生方法并用使用@JavascriptInterface注解**
  ```Java
  @JavascriptInterface
  public void show(String s){
      Toast.makeText(getApplication(), s, Toast.LENGTH_SHORT).show();
  }
  ```
  <br>
  **2.注册JavaScriptInterface**
  ```Java
  webView.addJavascriptInterface(this, "android");
  ```
  **addJavascriptInterface的作用是把this所代表的类映射为JavaScript中的android对象。**
  
  <br>
  **3.编写JavaScript代码**
  ```JavaScript
  function toastClick(){
      window.android.show("JavaScript called~!");
  }
  ```
<br>
<br>
**演示二 JavaScript调用有返回值的Java方法**

  **1.定义一个带返回值的Java方法，并使用@JavaInterface：**
  ```Java
    @JavaInterface
    public String getMessage(){
        return "Hello,boy~";
    }
  ```
  
  **2.添加JavaScript的映射**
  ```Java
    webView.addJavaScriptInterface(this,"Android");
  ```
  
  **3.通过JavaScript调用Java方法**
  ```JavaScript
  function showHello(){
      var str=window.Android.getMessage();
      console.log(str);
  }
 ```
 
 以上就是Js与WebView交互的一些介绍，希望能对你有帮助。
 <br>
 <br>
##WebView加载优化

###1. 案件打卡机

###2. 啦啦啦
  大家刻录机卡顿
 
 
 
  
